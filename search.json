[{"path":"https://bips-hb.github.io/survinng/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 Niklas Koenen Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":[]},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"generate-the-data","dir":"Articles","previous_headings":"Preprocessing","what":"Generate the Data","title":"Simulation of Time-dependent Effects","text":"consider simulated dataset following characteristics: 9,500 samples used training 500 samples used testing X1‚àºN(0,1)X_1 \\sim N(0, 1): time-dependent effect hazard: Initially negative effect Later transitions positive effect(implies opposite effect survival probability) X2‚àºùí©(0,1)X_2 \\sim \\mathcal{N}(0, 1): positive effect hazard ‚Üí Negative effect survival X3‚àºùí∞(0,1)X_3 \\sim \\mathcal{U}(0, 1): strong negative effect hazard ‚Üí Positive effect survival X4‚àºùí∞(‚àí1,1)X_4 \\sim \\mathcal{U}(-1, 1): effect hazard survival","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"load-models-and-data","dir":"Articles","previous_headings":"Preprocessing","what":"Load Models and Data","title":"Simulation of Time-dependent Effects","text":"models used vignette used main paper. models trained using survivalmodels package, training process shown , can found vignettes/articles/Sim_time_dependent directory GitHub.","code":"# Load data train <- readRDS(here(\"vignettes/articles/Sim_time_dependent/train.rds\")) test <- readRDS(here(\"vignettes/articles/Sim_time_dependent/test.rds\")) dat <- rbind(train, test)  # Load extracted models ext_coxtime <- readRDS(here(\"vignettes/articles/Sim_time_dependent/extracted_model_coxtime.rds\")) ext_deepsurv <- readRDS(here(\"vignettes/articles/Sim_time_dependent/extracted_model_deepsurv.rds\")) ext_deephit <- readRDS(here(\"vignettes/articles/Sim_time_dependent/extracted_model_deephit.rds\"))"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"performance","dir":"Articles","previous_headings":"Preprocessing","what":"Performance","title":"Simulation of Time-dependent Effects","text":"performance models evaluated using C-Index Integrated Brier Score (IBS). C-Index measures concordance predicted observed survival times, IBS quantifies accuracy survival predictions.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"create-explainer","dir":"Articles","previous_headings":"Preprocessing","what":"Create Explainer","title":"Simulation of Time-dependent Effects","text":"explain() function creates explainer object survival models. data argument specifies dataset used explanation, model argument specifies model explained. target argument indicates type prediction explained (e.g., ‚Äúsurvival‚Äù, ‚Äúrisk‚Äù, ‚Äúcumulative hazard‚Äù).","code":"exp_deephit <- survinng::explain(ext_deephit[[1]], data = test) exp_coxtime <- survinng::explain(ext_coxtime[[1]], data = test) exp_deepsurv <- survinng::explain(ext_deepsurv[[1]], data = test)"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"kaplan-meier-survival-curves","dir":"Articles","previous_headings":"Preprocessing","what":"Kaplan-Meier Survival Curves","title":"Simulation of Time-dependent Effects","text":"Kaplan-Meier survival curves plotted visualize survival probabilities time. x1 variable categorized two groups (low high) based median value. survival curves plotted group.","code":"# Categorize `x1` into bins (e.g., low, medium, high) dat$x1_group <- cut(dat$x1,                      breaks = quantile(dat$x1, probs = c(0, 0.5, 1)),                      labels = c(\"Low\", \"High\"),                      include.lowest = TRUE)  # Create a Surv object surv_obj <- Surv(dat$time, dat$status)  # Fit Kaplan-Meier survival curves stratified by `x1_group` km_fit <- survfit(surv_obj ~ x1_group, data = dat)  # Plot the KM curves km_plot <- ggsurvplot(km_fit,                        data = dat,                       xlab = \"Time t\",                       ylab = \"Survival Probability\",                       legend.title = \"x1 Group\",                       palette = c(\"#377EB8\", \"#E69F00\"),                         title = \"\")  km_plot$plot <- km_plot$plot +    theme_minimal(base_size = 17) +   theme(legend.position = \"bottom\") +   geom_rug(data = test, aes(x = time), sides = \"bl\", linewidth = 0.5, alpha = 0.5, inherit.aes = FALSE) km_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"survival-prediction","dir":"Articles","previous_headings":"Preprocessing","what":"Survival Prediction","title":"Simulation of Time-dependent Effects","text":"survival predictions test dataset computed using predict() function. type argument specifies type prediction made (e.g., ‚Äúsurvival‚Äù, ‚Äúrisk‚Äù, ‚Äúcumulative hazard‚Äù). survival predictions plotted set instances interest.","code":"# Print instances of interest td_ids <- c(79, 428) print(test[td_ids, ]) #>          time status        x1         x2         x3         x4 #> 1535 4.306154      1 0.1934749 -0.3069111 -0.1475012  0.6370386 #> 8202 1.417212      1 0.7526954 -0.3781274 -1.1500862 -0.6418508  # Compute Vanilla Gradient grad_cox <- surv_grad(exp_coxtime, target = \"survival\", instance = td_ids) grad_deephit <- surv_grad(exp_deephit, target = \"survival\", instance = td_ids) grad_deepsurv <- surv_grad(exp_deepsurv, target = \"survival\", instance = td_ids)  # Plot survival predictions surv_plot <- cowplot::plot_grid(   plot(grad_cox, type = \"pred\") ,   plot(grad_deephit, type = \"pred\"),   plot(grad_deepsurv, type = \"pred\"),   nrow = 1, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\"),   label_x = 0.03,         label_size = 14)  surv_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"explainable-ai","dir":"Articles","previous_headings":"","what":"Explainable AI","title":"Simulation of Time-dependent Effects","text":"following sections demonstrate application various gradient-based explanation methods survival models. methods include Grad(t), SmoothGrad(t), IntGrad(t), GradSHAP(t), corresponding plots shown main body paper.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"gradt-sensitivity","dir":"Articles","previous_headings":"Explainable AI","what":"Grad(t) (Sensitivity)","title":"Simulation of Time-dependent Effects","text":"compute gradient survival predictions respect input features. surv_grad() function computes gradients specified instances.","code":"# Plot attributions grad_plot <- cowplot::plot_grid(   plot(grad_cox, type = \"attr\") ,   plot(grad_deephit, type = \"attr\"),   plot(grad_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) grad_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"smoothgradt-sensitivity","dir":"Articles","previous_headings":"Explainable AI","what":"SmoothGrad(t) (Sensitivity)","title":"Simulation of Time-dependent Effects","text":"SmoothGrad(t) method adds noise input features computes average gradient multiple noisy samples. approach helps reduce noise gradient estimates provides clearer picture feature importance.  relevance curves derived output-sensitive methods effectively reveal time-dependent effect x1x_1 survival predictions, indicating positive effect earlier times negative effect later . time-dependent effect accurately captured CoxTime DeepHit, DeepSurv, inherently constrained PH assumption thus unable model time-dependence.","code":"# Compute SmoothGrad sg_cox <- surv_smoothgrad(exp_coxtime, target = \"survival\", instance = td_ids,                            n = 50, noise_level = 0.1) sg_deephit <- surv_smoothgrad(exp_deephit, target = \"survival\", instance = td_ids,                                n = 50, noise_level = 0.1) sg_deepsurv <- surv_smoothgrad(exp_deepsurv, target = \"survival\", instance = td_ids,                                 n = 50, noise_level = 0.1)  # Plot attributions smoothgrad_plot <- cowplot::plot_grid(   plot(sg_cox, type = \"attr\"),    plot(sg_deephit, type = \"attr\"),    plot(sg_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) smoothgrad_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"intgradt","dir":"Articles","previous_headings":"Explainable AI","what":"IntGrad(t)","title":"Simulation of Time-dependent Effects","text":"IntGrad(t) method computes integral gradients along straight line path reference point input instance. method provides comprehensive view feature importance considering cumulative effect features time. addition time-dependence feature effects, difference--reference methods (.e., IntGrad(t) GradSHAP(t)) provide insights relative scale, direction, magnitude feature effects comparing predictions meaningful reference.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"zero-baseline","dir":"Articles","previous_headings":"Explainable AI > IntGrad(t)","what":"Zero baseline","title":"Simulation of Time-dependent Effects","text":"zero baseline reference point features set zero.   Contribution plots effectively visualize normalized absolute contribution feature difference reference (survival) prediction time.  Complementarily, force plots emphasize relative contribution direction feature set representative survival times.","code":"# Compute IntegratedGradient with 0 baseline x_ref <- matrix(c(0,0,0,0), nrow = 1) ig0_cox <- surv_intgrad(exp_coxtime, instance = td_ids, n = 50, x_ref = x_ref) ig0_deephit <- surv_intgrad(exp_deephit, instance = td_ids, n = 50, x_ref = x_ref) ig0_deepsurv <- surv_intgrad(exp_deepsurv, instance = td_ids, n = 50, x_ref = x_ref)  # Plot attributions intgrad0_plot <- cowplot::plot_grid(   plot(ig0_cox, type = \"attr\"),    plot(ig0_deephit, type = \"attr\"),    plot(ig0_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot # Plot attributions intgrad0_plot_comp <- cowplot::plot_grid(   plot(ig0_cox, add_comp = \"all\", type = \"attr\"),    plot(ig0_deephit, add_comp = \"all\", type = \"attr\"),    plot(ig0_deepsurv, add_comp = \"all\", type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot_comp # Plot contributions intgrad0_plot_contr <- cowplot::plot_grid(   plot(ig0_cox, type = \"contr\"),    plot(ig0_deephit, type = \"contr\"),    plot(ig0_deepsurv, type = \"contr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot_contr # Plot force intgrad0_plot_force <- cowplot::plot_grid(   plot(ig0_cox, type = \"force\"),   plot(ig0_deephit, type = \"force\"),   plot(ig0_deepsurv, type = \"force\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot_force"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_dependent.html","id":"gradshapt","dir":"Articles","previous_headings":"Explainable AI","what":"GradSHAP(t)","title":"Simulation of Time-dependent Effects","text":"GradSHAP(t) method computes SHAP values survival predictions. provides measure contribution feature survival predictions, taking account time-dependent effects.     example, opposite effects low vs.¬†high values x1x_1 effectively captured plots. observation 79, low x1x_1 positively influences survival later time points (t>2t>2) compared overall average survival dataset, resulting largest contributions occurring times. Conversely, observation 428, high x1x_1 induces substantial contributions earlier time points (t<2t<2), negatively impacts survival later times, reflecting early event consequence high x1x_1 strong negative effect x3x_3. average normalized absolute contribution, displayed right side contribution plots, offers time-independent measure feature importance, confirming dominance x3x_3 survival prediction instance 428. Additionally, visualizations suggest CoxTime partially attributes time-varying effect x1x_1 features, model, non-parametric lacking explicit knowledge time-dependent functional form, struggles precisely disentangle localize effect.","code":"# Compute GradShap(t) gshap_cox <- surv_gradSHAP(exp_coxtime, instance = td_ids, n = 50, num_samples = 100) gshap_deephit <- surv_gradSHAP(exp_deephit, instance = td_ids, n = 50, num_samples = 100) gshap_deepsurv <- surv_gradSHAP(exp_deepsurv, instance = td_ids, n = 50, num_samples = 100)  # Plot attributions gshap_plot <- cowplot::plot_grid(   plot(gshap_cox, type = \"attr\"),    plot(gshap_deephit, type = \"attr\"),    plot(gshap_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot # Plot attributions gshap_plot_comp <- cowplot::plot_grid(   plot(gshap_cox, add_comp = \"all\", type = \"attr\"),    plot(gshap_deephit, add_comp = \"all\", type = \"attr\"),    plot(gshap_deepsurv, add_comp = \"all\", type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot_comp # Plot contributions gshap_plot_contr <- cowplot::plot_grid(   plot(gshap_cox, type = \"contr\"),    plot(gshap_deephit, type = \"contr\"),    plot(gshap_deepsurv, type = \"contr\"),    nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot_contr # Plot force gshap_plot_force <- cowplot::plot_grid(   plot(gshap_cox, type = \"force\"),   plot(gshap_deephit, type = \"force\"),   plot(gshap_deepsurv, type = \"force\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot_force"},{"path":[]},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"generate-the-data","dir":"Articles","previous_headings":"Preprocessing","what":"Generate the data","title":"Simulation of Time-independent Effects","text":"consider simulated dataset following characteristics: 9,500 samples used training 500 samples used testing X1‚àºN(0,1)X_1 \\sim N(0, 1): positive effect hazard ‚Üí Negative effect survival X2‚àºU(0,1)X_2 \\sim U(0, 1): strong negative effect hazard ‚Üí Positive effect survival X3‚àºU(‚àí1,1)X_3 \\sim U(-1, 1): effect hazard survival Time-dependency: None covariates time-varying effects","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"load-models-and-data","dir":"Articles","previous_headings":"Preprocessing","what":"Load Models and Data","title":"Simulation of Time-independent Effects","text":"models used vignette used main paper. models trained using survivalmodels package, training process shown , can found vignettes/articles/Sim_time_independent directory GitHub.","code":"# Load data train <- readRDS(here(\"vignettes/articles/Sim_time_independent/train.rds\")) test <- readRDS(here(\"vignettes/articles/Sim_time_independent/test.rds\")) dat <- rbind(train, test)  # Load extracted models ext_coxtime <- readRDS(here(\"vignettes/articles/Sim_time_independent/ext_coxtime.rds\")) ext_deepsurv <- readRDS(here(\"vignettes/articles/Sim_time_independent/ext_deepsurv.rds\")) ext_deephit <- readRDS(here(\"vignettes/articles/Sim_time_independent/ext_deephit.rds\"))"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"performance","dir":"Articles","previous_headings":"Preprocessing","what":"Performance","title":"Simulation of Time-independent Effects","text":"performance models evaluated using C-Index Integrated Brier Score (IBS). C-Index measures concordance predicted observed survival times, IBS quantifies accuracy survival predictions.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"create-explainer","dir":"Articles","previous_headings":"Preprocessing","what":"Create Explainer","title":"Simulation of Time-independent Effects","text":"explain() function creates explainer object survival models. data argument specifies dataset used explanation, model argument specifies model explained. target argument indicates type prediction explained (e.g., ‚Äúsurvival‚Äù, ‚Äúrisk‚Äù, ‚Äúcumulative hazard‚Äù).","code":"exp_deephit <- survinng::explain(ext_deephit[[1]], data = test) exp_coxtime <- survinng::explain(ext_coxtime[[1]], data = test) exp_deepsurv <- survinng::explain(ext_deepsurv[[1]], data = test)"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"survival-prediction","dir":"Articles","previous_headings":"Preprocessing","what":"Survival Prediction","title":"Simulation of Time-independent Effects","text":"survival predictions test dataset computed using predict() function. type argument specifies type prediction made (e.g., ‚Äúsurvival‚Äù, ‚Äúrisk‚Äù, ‚Äúcumulative hazard‚Äù). survival predictions plotted set instances interest.","code":"# Print instances of interest tid_ids <- c(13, 387) print(test[tid_ids, ]) #>           time status        x1        x2          x3 #> 343  2.6653596      1 -0.434617 0.1162303 -0.08053765 #> 7906 0.9577924      1  2.454611 0.2462072 -0.04249294  # Compute Vanilla Gradient grad_cox <- surv_grad(exp_coxtime, target = \"survival\", instance = tid_ids) grad_deephit <- surv_grad(exp_deephit, target = \"survival\", instance = tid_ids) grad_deepsurv <- surv_grad(exp_deepsurv, target = \"survival\", instance = tid_ids)  # Plot survival predictions surv_plot <- cowplot::plot_grid(   plot(grad_cox, type = \"pred\"),   plot(grad_deephit, type = \"pred\"),   plot(grad_deepsurv, type = \"pred\"),   nrow = 1, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\"),   label_x = 0.03,         label_size = 14)  surv_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"explainable-ai","dir":"Articles","previous_headings":"","what":"Explainable AI","title":"Simulation of Time-independent Effects","text":"following sections demonstrate application various gradient-based explanation methods survival models. methods include Grad(t), SmoothGrad(t), G x (t), SmoothGrad x (t), IntGrad(t), GradSHAP(t). method provides insights contributions covariates survival predictions.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"gradt-sensitivity","dir":"Articles","previous_headings":"Explainable AI","what":"Grad(t) (Sensitivity)","title":"Simulation of Time-independent Effects","text":"compute gradient survival predictions respect input features. surv_grad() function computes gradients specified instances.","code":"# Plot attributions grad_plot <- cowplot::plot_grid(   plot(grad_cox, type = \"attr\"),   plot(grad_deephit, type = \"attr\"),   plot(grad_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) grad_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"smoothgradt-sensitivity","dir":"Articles","previous_headings":"Explainable AI","what":"SmoothGrad(t) (Sensitivity)","title":"Simulation of Time-independent Effects","text":"SmoothGrad(t) method adds noise input features computes average gradient multiple noisy samples. approach helps reduce noise gradient estimates provides clearer picture feature importance.","code":"# Compute SmoothGrad sg_cox <- surv_smoothgrad(exp_coxtime, target = \"survival\", instance = tid_ids, n = 50, noise_level = 0.1) sg_deephit <- surv_smoothgrad(exp_deephit, target = \"survival\", instance = tid_ids, n = 50, noise_level = 0.1) sg_deepsurv <- surv_smoothgrad(exp_deepsurv, target = \"survival\", instance = tid_ids, n = 50, noise_level = 0.1)  # Plot attributions smoothgrad_plot <- cowplot::plot_grid(   plot(sg_cox, type = \"attr\"),    plot(sg_deephit, type = \"attr\"),    plot(sg_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) smoothgrad_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"grad-x-it","dir":"Articles","previous_headings":"Explainable AI","what":"Grad x I(t)","title":"Simulation of Time-independent Effects","text":"Grad x (t) method computes gradient survival predictions respect input features multiplies survival predictions . approach provides insights true local effects covariates survival prediction.","code":"# Compute GradientxInput gradin_cox <- surv_grad(exp_coxtime, instance = tid_ids, times_input = TRUE) gradin_deephit <- surv_grad(exp_deephit, instance = tid_ids, times_input = TRUE) gradin_deepsurv <- surv_grad(exp_deepsurv, instance = tid_ids, times_input = TRUE)  # Plot attributions gradin_plot <- cowplot::plot_grid(   plot(gradin_cox, type = \"attr\"),    plot(gradin_deephit, type = \"attr\"),    plot(gradin_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gradin_plot # Plot attributions grad_gradin_plot <- cowplot::plot_grid(   plot(grad_deepsurv, type = \"attr\") ,   plot(gradin_deepsurv, type = \"attr\"),   nrow = 2, labels = c(\"DeepSurv\", \"DeepSurv\")) grad_gradin_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"smoothgrad-x-it","dir":"Articles","previous_headings":"Explainable AI","what":"SmoothGrad x I(t)","title":"Simulation of Time-independent Effects","text":"SmoothGrad x (t) method adds noise input features computes average gradient multiple noisy samples, multiplied survival predictions. approach helps reduce noise gradient estimates provides clearer picture feature importance.","code":"# Compute SmoothGradxInput sgin_cox <- surv_smoothgrad(exp_coxtime, instance = tid_ids, n = 50, noise_level = 0.3,                           times_input = TRUE) sgin_deephit <- surv_smoothgrad(exp_deephit, instance = tid_ids, n = 50, noise_level = 0.3,                               times_input = TRUE) sgin_deepsurv <- surv_smoothgrad(exp_deepsurv, instance = tid_ids, n = 50, noise_level = 0.3,                                times_input = TRUE)  # Plot attributions smoothgradin_plot <- cowplot::plot_grid(   plot(sgin_cox, type = \"attr\"),    plot(sgin_deephit, type = \"attr\"),    plot(sgin_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) smoothgradin_plot"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"intgradt","dir":"Articles","previous_headings":"Explainable AI","what":"IntGrad(t)","title":"Simulation of Time-independent Effects","text":"IntGrad(t) method computes integral gradients along straight line path reference point input instance. method provides comprehensive view feature importance considering cumulative effect features time.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"zero-baseline","dir":"Articles","previous_headings":"Explainable AI > IntGrad(t)","what":"Zero baseline","title":"Simulation of Time-independent Effects","text":"zero baseline reference point features set zero.   Contribution plots effectively visualize normalized absolute contribution feature difference reference (survival) prediction time.  Complementarily, force plots emphasize relative contribution direction feature set representative survival times.","code":"# Compute IntegratedGradient with 0 baseline x_ref <- matrix(c(0,0,0), nrow = 1) ig0_cox <- surv_intgrad(exp_coxtime, instance = tid_ids, n = 50, x_ref = x_ref) ig0_deephit <- surv_intgrad(exp_deephit, instance = tid_ids, n = 50, x_ref = x_ref) ig0_deepsurv <- surv_intgrad(exp_deepsurv, instance = tid_ids, n = 50, x_ref = x_ref)  # Plot attributions intgrad0_plot <- cowplot::plot_grid(   plot(ig0_cox, type = \"attr\"),    plot(ig0_deephit, type = \"attr\"),    plot(ig0_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot # Plot attributions intgrad0_plot_comp <- cowplot::plot_grid(   plot(ig0_cox, add_comp = \"all\", type = \"attr\"),    plot(ig0_deephit, add_comp = \"all\", type = \"attr\"),    plot(ig0_deepsurv, add_comp = \"all\", type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot_comp # Plot contributions intgrad0_plot_contr <- cowplot::plot_grid(   plot(ig0_cox, type = \"contr\"),    plot(ig0_deephit, type = \"contr\"),    plot(ig0_deepsurv, type = \"contr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot_contr # Plot force intgrad0_plot_force <- cowplot::plot_grid(   plot(ig0_cox, type = \"force\"),   plot(ig0_deephit, type = \"force\"),   plot(ig0_deepsurv, type = \"force\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) intgrad0_plot_force"},{"path":"https://bips-hb.github.io/survinng/articles/Sim_time_independent.html","id":"gradshapt","dir":"Articles","previous_headings":"Explainable AI","what":"GradSHAP(t)","title":"Simulation of Time-independent Effects","text":"GradSHAP(t) method computes SHAP values survival predictions. provides measure contribution feature survival predictions, taking account time-dependent effects.","code":"# Compute GradShap gshap_cox <- surv_gradSHAP(exp_coxtime, instance = tid_ids, n = 50, num_samples = 100) gshap_deephit <- surv_gradSHAP(exp_deephit, instance = tid_ids, n = 50, num_samples = 100) gshap_deepsurv <- surv_gradSHAP(exp_deepsurv, instance = tid_ids, n = 50, num_samples = 100)  # Plot attributions gshap_plot <- cowplot::plot_grid(   plot(gshap_cox, type = \"attr\"),    plot(gshap_deephit, type = \"attr\"),    plot(gshap_deepsurv, type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot # Plot attributions gshap_plot_comp <- cowplot::plot_grid(   plot(gshap_cox, add_comp = \"all\", type = \"attr\"),    plot(gshap_deephit, add_comp = \"all\", type = \"attr\"),    plot(gshap_deepsurv, add_comp = \"all\", type = \"attr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot_comp # Plot contributions  gshap_plot_contr <- cowplot::plot_grid(   plot(gshap_cox, type = \"contr\"),    plot(gshap_deephit, type = \"contr\"),    plot(gshap_deepsurv, type = \"contr\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot_contr # Plot force gshap_plot_force <- cowplot::plot_grid(   plot(gshap_cox, type = \"force\"),    plot(gshap_deephit, type = \"force\"),   plot(gshap_deepsurv, type = \"force\"),   nrow = 3, labels = c(\"CoxTime\", \"DeepHit\", \"DeepSurv\")) gshap_plot_force"},{"path":"https://bips-hb.github.io/survinng/articles/how_to_load_model.html","id":"load-a-base-torch-model","dir":"Articles","previous_headings":"","what":"Load a base torch model","title":"How to load my model?","text":"simplest way load model. model must torch::nn_module input (tabular, image, multimodal, etc.) can passed long output dimension fits expected survival deep learning architecture. means: DeepHit model, output dimension must shape (batch_size, n_risks, n_time_bins) n_risks number competing risks n_time_bins number time bins. DeepSurv CoxTime models, output dimension must shape (batch_size, 1), since models designed predict risk single event Cox-based.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/how_to_load_model.html","id":"example-deephit-model","dir":"Articles","previous_headings":"Load a base torch model","what":"Example DeepHit model","title":"How to load my model?","text":"example, create simple DeepHit model using torch package. model 5 competing risks 20 time bins. input dimension 10 features. model simple feedforward neural network two hidden layers. Important note output dimension reshaped (batch_size, n_risks, n_time_bins). Now, (untrained) base model corresponding data. next step create survinng explainer object. done using explain() function. function takes model, data, time bins (required DeepHit model) input internally combines base model DeepHit architecture. model_type argument set \"deephit\" indicate model DeepHit model. function return explainer object can used compute implemented gradient-based feature attribution methods survival context.","code":"library(torch)  n_risks <- 5 n_time_bins <- 20 n_features <- 10  # Create the base model and data base_model_deephit <- nn_module(   initialize = function() {     self$net <- nn_sequential(       nn_linear(n_features, 128),       nn_relu(),       nn_linear(128, n_risks * n_time_bins)     )   },   forward = function(x) {     self$net(x) %>%       torch_reshape(c(-1, n_risks, n_time_bins))   } ) model_deephit <- base_model_deephit() data <- torch_randn(50, n_features) time_bins <- seq(0, 10, length.out = n_time_bins)  # Check output output <- model_deephit(data) print(output$shape) #> [1] 50  5 20 # Create explainer object exp_deephit <- survinng::explain(model_deephit, data = data, model_type = \"deephit\",                                  time_bins = time_bins) print(exp_deephit) #> Explainer for DeepHit model #> ----------------------------------- #> Model Class: DeepHit #> Number of instances in the input data:  50  #> Competing risks: Not specified #> Number of time bins in the model:  20  #> Model parameters: #>  - Number of input modalities:  1  #>  - Number of features:  10  #>  - Preprocessing function applied: Yes #>  #> Features (first 5 shown): #> X1, X2, X3, X4, X5  #> ----------------------------------- #> To see more details, explore the individual elements of the object.  # Calculate gradients grad <- surv_grad(exp_deephit, instance = c(1,3))  # Plot gradients plot(grad)"},{"path":"https://bips-hb.github.io/survinng/articles/how_to_load_model.html","id":"example-deepsurv-model","dir":"Articles","previous_headings":"Load a base torch model","what":"Example DeepSurv model","title":"How to load my model?","text":"example, create simple DeepSurv model using torch package. Since DeepSurv Cox-based model, output dimension shape (batch_size, 1) need baseline hazard function. Now, (untrained) base model corresponding data, including baseline hazard values next step create survinng explainer object. done using explain() function. function takes model, data, baseline hazard (required DeepSurv model) input internally combines base model DeepSurv architecture. model_type argument set \"deepsurv\" indicate model DeepSurv model.","code":"library(torch)  n_features <- 10  # Create baseline hazard function (50 time points) time <- seq(0, 10, length.out = 50) hazard <- exp(-(time - 5)^2 / 5) base_hazard <- data.frame(time = time, hazard = hazard)  # Create the base model and data base_model_deepsurv <- nn_module(   initialize = function() {     self$net <- nn_sequential(       nn_linear(n_features, 128),       nn_relu(),       nn_linear(128, 1, bias = FALSE)     )   },   forward = function(x) {     self$net(x)   } ) model_deepsurv <- base_model_deepsurv() data <- torch_randn(50, n_features)  # Check output output <- model_deepsurv(data) print(output$shape) #> [1] 50  1 # Create explainer object exp_deepsurv <- survinng::explain(model_deepsurv, data = data,                                    model_type = \"deepsurv\",                                   baseline_hazard = base_hazard) print(exp_deepsurv) #> Explainer for DeepSurv model #> ----------------------------------- #> Model Class: DeepSurv #> Number of instances in the input data:  50  #> Number of timepoints in the model:  50 (min: 0 , max: 10 ) #> Model parameters: #>  - Number of input modalities:  1  #>  - Number of features:  10  #>  - Baseline hazard function: Yes #>  - Preprocessing function applied: Yes #>  #> Features (first 5 shown): #> X1, X2, X3, X4, X5  #> ----------------------------------- #> To see more details, explore the individual elements of the object.  # Calculate IntGrad(t) ig <- surv_intgrad(exp_deepsurv, instance = c(1,3))  # Show results as a contribution plot plot(ig, type = \"contr\")"},{"path":"https://bips-hb.github.io/survinng/articles/how_to_load_model.html","id":"example-coxtime-model","dir":"Articles","previous_headings":"Load a base torch model","what":"Example CoxTime model","title":"How to load my model?","text":"example, create simple CoxTime model using torch package. similar DeepSurv modelm .e., output dimension base model shape (batch_size, 1) need baseline hazard function since Cox-based model. However, time points integrated input features, model n_features + 1 input features. Currently, default function adding time points input features following one assumes tabular data: However, can pass preprocessing function explain() function using preprocess_fun argument, option still experimental fully tested. following code, create base model data CoxTime architecture. model 10 + 1 features 50 time points baseline hazard function (basically DeepSurv model Section): Now, (untrained) base model corresponding data, including baseline hazard values. next step create survinng explainer object. done using explain() function. function takes model, data, baseline hazard (required CoxTime model) input internally combines base model CoxTime architecture. model_type argument set \"coxtime\" indicate model CoxTime model. preprocess_fun argument set function defined earlier add time points input features.","code":"n_features <- 10 x <- torch_randn(50, n_features) t <- torch_linspace(0, 10, steps = 50)  preprocess_fun <- function(x) {   batch_size <- x$size(1)      # Input (batch_size, n_features) -> (batch_size * t, n_features) (replicate each row t times)   res <- x$repeat_interleave(length(t), dim = 1)      # Add time to input   time <- torch_vstack(replicate(batch_size, t$unsqueeze(-1)))      # Combine both and return   torch::torch_cat(list(res, time), dim = -1) }  # Input shape print(x$shape) #> [1] 50 10  # Shape after preprocessing preprocess_fun(x)$shape #> [1] 2500   11 library(torch) n_features <- 10  # Create baseline hazard function (50 time points) time <- seq(0, 10, length.out = 50) hazard <- exp(-(time - 5)^2 / 5) base_hazard <- data.frame(time = time, hazard = hazard)  # Create the base model and data base_model_coxtime <- nn_module(   initialize = function() {     self$net <- nn_sequential(       nn_linear(n_features + 1, 128),       nn_relu(),       nn_linear(128, 1, bias = FALSE)     )   },   forward = function(x) {     self$net(x)   } ) model_coxtime <- base_model_coxtime() data <- torch_randn(50, n_features)  # Check output output <- model_coxtime(preprocess_fun(data)) print(output$shape) # the instances are replicated t times #> [1] 2500    1 # Create explainer object exp_coxtime <- survinng::explain(model_coxtime, data = data,                                   model_type = \"coxtime\",                                  baseline_hazard = base_hazard) print(exp_coxtime) #> Explainer for CoxTime model #> ----------------------------------- #> Model Class: CoxTime #> Number of instances in the input data:  50  #> Number of timepoints in the model:  50  #> Model parameters: #>  - Number of input modalities:  1  #>  - Number of features:  10  #>  - Baseline hazard function: Yes #>  - Preprocessing function applied: Yes #>  #> Features (first 5 shown): #> X1, X2, X3, X4, X5  #> ----------------------------------- #> To see more details, explore the individual elements of the object.  # Calculate IntGrad(t) ig <- surv_intgrad(exp_coxtime, instance = c(1,3))  # Show results as a contribution plot plot(ig, type = \"contr\")"},{"path":"https://bips-hb.github.io/survinng/articles/how_to_load_model.html","id":"load-a-survivalmodels-model","dir":"Articles","previous_headings":"","what":"Load a survivalmodels model","title":"How to load my model?","text":"survivalmodels package R package survival analysis using deep learning. Especially deep learning models, uses pycox package Python hood via reticulate. survinng package designed load models trained survivalmodels directly. However, issues torch R (.e., LibTorch) Pytorch Python loaded session (see issue #815). Therefore, keep training procedure using survivalmodels separate session using callr. following example, train default DeepHit, DeepSurv Coxtime model using survivalmodels package. models trained lung dataset survival package. Now, trained models models list. models extracted using extract_model() function survinng package. objects data explained can passed explain() function create survinng explainer objects. explain() function automatically detect model type create corresponding explainer object, .e., model_type argument needed case. Using explainer objects, can compute gradient-based feature attribution methods. instance argument used specify instances explanations computed.  plot() function, can visualize results. type argument can set \"pred\" show predictions model, \"attr\" show feature attribution values, \"contr\" show contribution plots.","code":"library(survival) library(callr)  # Load lung dataset data(cancer, package = \"survival\") data <- na.omit(cancer[, c(1, 4, 5, 6, 7, 10, 2, 3)])  # Train models in separate session models <- callr::r(function(data) {   library(survivalmodels)   library(survival)      # Set seed for reproducibility   set.seed(42)   set_seed(42)      # Make sure pycox is installed   install_pycox(install_torch = TRUE)      # Fit the DeepSurv model   fit_deepsurv <- deepsurv(Surv(time, status) ~ ., data = data, epochs = 10,                            num_nodes = 8L)      # Fit the DeepHit model   fit_deephit <- deephit(Surv(time, status) ~ ., data = data, epochs = 10,                          cuts = 30, num_nodes = 8L)      # Fit the CoxTime model   fit_coxtime <- coxtime(Surv(time, status) ~ ., data = data, epochs = 10,                          num_nodes = 8L)    # Extract the models using `survinng`   ext_deepsurv <- survinng::extract_model(fit_deepsurv)   ext_deephit <- survinng::extract_model(fit_deephit)   ext_coxtime <- survinng::extract_model(fit_coxtime)      # Return the extracted models   list(deepsurv = ext_deepsurv, deephit = ext_deephit, coxtime = ext_coxtime) }, args = list(data = data)) # Create explainer objects exp_deepsurv <- survinng::explain(models$deepsurv, data = data) exp_deephit <- survinng::explain(models$deephit, data = data) exp_coxtime <- survinng::explain(models$coxtime, data = data) # Show instances to be explained ids <- c(1, 76) data[ids, ] #>    inst age sex ph.ecog ph.karno wt.loss time status #> 2     3  68   1       0       90      15  455      2 #> 83   11  42   1       1       80       8  196      1  # Calculate feature attribution methods grad <- surv_grad(exp_deepsurv, instance = ids) ig <- surv_intgrad(exp_deephit, instance = ids) shap <- surv_gradSHAP(exp_coxtime, instance = ids)  # Show the predictions plot(shap, type = \"pred\") library(cowplot) library(ggplot2)  plot_grid(   plot(ig, type = \"contr\", aggregate = TRUE) + ggtitle(\"IntGrad(t) (aggregated)\"),   plot(shap, type = \"attr\") + ggtitle(\"SHAP\"),   ncol = 2 )"},{"path":"https://bips-hb.github.io/survinng/articles/how_to_load_model.html","id":"load-a-pycox-python-model","dir":"Articles","previous_headings":"","what":"Load a pycox Python model","title":"How to load my model?","text":"also possible load models trained Python using pycox package. Basically, procedure another torch::nn_module model. difference model needs loaded R described Pyton R article torch package. means, model architecture must rebuilt R weights parameters must loaded Python model. illustration, use CoxTime model pycox Jupyter notebook METABRIC dataset. training model, follow steps extract base hazard function model weights (model x_test defined mentioned notebook): Now, tricky part rebuilding model architecture R names parameters Python model. done following code: model architecture now rebuilt R weights loaded Python model. next step load baseline hazard function data explained. Additionally, since notebook uses label transformation, need rebuild transformation function R. However, simple mean standard deviation transformation, can use labtrans argument explain() function define transformation function. labtrans argument list two functions: transform transform_inv. Now, can create survinng explainer object using explain() function apply implemented gradient-based feature attribution methods model. model_type argument set \"coxtime\" indicate model CoxTime model labtrans argument set defined transformation.  similar way, can also load DeepSurv DeepHit models pycox. difference model architecture must changed accordingly. model_type argument set \"deepsurv\" \"deephit\" indicate model type.","code":"import pandas as pd  # We use only a sample of the data for the baseline hazard base_hazard = model.compute_baseline_hazards(sample = 200)  # Save base hazard as csv pd_base_hazard = pd.DataFrame({     'time': base_hazard.index.to_numpy(),      'hazard': base_hazard.to_numpy()}) pd_base_hazard.to_csv('base_hazard.csv', index = False)  # Save model weights (not the  whole model!) torch.save(model.net.net.state_dict(), 'model.pt')  # Save data to be explained df_train.to_csv('df_train.csv', index=False) pd.DataFrame(x_val, columns = df_val.columns[0:9]).to_csv('x_val.csv', index=False) # Rebuild a dense layer BaseMLP_dense <- nn_module(   initialize = function(in_feat, out_feat) {     self$linear <- nn_linear(in_feat, out_feat)     self$batch_norm <- nn_batch_norm1d(out_feat)   },    forward = function(x) {     x <- self$linear(x)     x <- nn_relu()(x)     x <- self$batch_norm(x)   } )  # Rebuild the whole model BaseMLP <- torch::nn_module(   classname = \"BaseMLP\",   initialize = function() {          self$net <- nn_sequential(       BaseMLP_dense(10, 32),       BaseMLP_dense(32, 32),       nn_linear(32, 1, bias = FALSE)     )   },   forward = function(x) {     if (is.list(x)) x <- x[[1]]     self$net(x)   } )  # Create model and load state dict model <- BaseMLP() state_dict <- load_state_dict(here(\"vignettes/articles/how_to_load_model/model.pt\")) model$load_state_dict(state_dict) model$eval() print(model) #> An `nn_module` containing 1,568 parameters. #>  #> ‚îÄ‚îÄ Modules ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚Ä¢ net: <nn_sequential> #1,568 parameters # Load base hazard and data base_hazard <- read.csv(here(\"vignettes/articles/how_to_load_model/base_hazard.csv\")) df_train <- read.csv(here(\"vignettes/articles/how_to_load_model/df_train.csv\")) x_val <- read.csv(here(\"vignettes/articles/how_to_load_model/x_val.csv\"))  # Rebuild the label transformation mean <- mean(df_train$duration) sd <- sd(df_train$duration) labtrans <- list(   transform = function(x) (x - mean) / sd,   transform_inv = function(x) x * sd + mean ) # Create explainer explainer <- survinng::explain(model, data = x_val, model_type = \"coxtime\",                                baseline_hazard = base_hazard,                                labtrans = labtrans)  # Calculate GradSHAP(t) grad_shap <- surv_gradSHAP(explainer, instance = c(1, 3))  # Show predictions p1 <- plot(grad_shap, type = \"pred\")  # Show attribution results p2 <- plot(grad_shap, type = \"attr\", add_comp = c(\"pred_diff\"))  # Show contribution percentages p3 <- plot(grad_shap, type = \"contr\")  cowplot::plot_grid(p1, p2, p3, ncol = 1)"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Example on Real Multi-modal Medical Data","text":"begin loading necessary libraries setting seeds ensure reproducibility. helper functions used image processing visualization sourced separate utility script can found vignettes/articles/real_data directory online GitHub repository.","code":"library(survinng) library(torch) library(torchvision) library(ggplot2) library(data.table) library(cowplot) library(dplyr) library(here)  # Load helper functions source(here(\"vignettes/articles/real_data/utils.R\"))  # Set seeds for reproducibility set.seed(42) torch_manual_seed(42)"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"load-model-and-metadata","dir":"Articles","previous_headings":"","what":"Load model and metadata","title":"Example on Real Multi-modal Medical Data","text":"first load trained model along corresponding metadata, including number outputs image joint components, whether bias term included, number tabular features. model‚Äôs performance briefly summarized using two commonly used survival metrics: Concordance index Integrated Brier Score. restoring model‚Äôs state dictionary, replicate multi-modal network structure consisting ResNet34 backbone image branch linear transformation tabular input. required files available vignettes/articles/real_data directory online GitHub repository folder.","code":"# Load model metadata model_metadata <- read.csv(here(\"vignettes/articles/real_data/metadata.csv\")) n_img_out <- model_metadata$n_img_out n_out <- model_metadata$n_out out_bias <- as.logical(model_metadata$out_bias) n_tab_feat <- model_metadata$Number.of.tabular.features  # Show performance results model_metadata[, c(\"Concordance\", \"Integrated.Brier.score\")] #>   Concordance Integrated.Brier.score #> 1   0.7133996              0.0919935  # Load model state dict model_state_dict <- load_state_dict(here(\"vignettes/articles/real_data/model.pt\"))  # Replicate model net_image <- torchvision::model_resnet34(num_classes = n_img_out) model <- MultiModalModel(net_image, tabular_features = rep(1, n_tab_feat),                          n_out = n_out, n_img_out = n_img_out, out_bias = out_bias)  # Load model state dict model <- model$load_state_dict(model_state_dict) model$eval() model #> An `nn_module` containing 21,518,292 parameters. #>  #> ‚îÄ‚îÄ Modules ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ #> ‚Ä¢ net_images: <resnet> #21,416,000 parameters #> ‚Ä¢ fc1: <nn_linear> #66,816 parameters #> ‚Ä¢ fc2: <nn_linear> #32,896 parameters #> ‚Ä¢ relu: <nn_relu> #0 parameters #> ‚Ä¢ drop_0_3: <nn_dropout> #0 parameters #> ‚Ä¢ drop_0_4: <nn_dropout> #0 parameters #> ‚Ä¢ out: <nn_linear> #2,580 parameters"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"load-data","dir":"Articles","previous_headings":"","what":"Load data","title":"Example on Real Multi-modal Medical Data","text":"Next, prepare input data evaluation explanation. includes: tabular dataset containing numeric predictors. Corresponding image files test set. Images preprocessed using standard transformations (center cropping normalization) stacked single tensor. tabular inputs converted Torch tensor compatible model input format. Note: tabular image data can found vignettes/articles/real_data directory online GitHub repository folder.","code":"data <- read.csv(here(\"vignettes/articles/real_data/deephit_tabular_data.csv\")) test_images <- list.files(here(\"vignettes/articles/real_data/test\"), full.names = FALSE)  # Filter data data <- data[data$full_path %in% test_images, ] data_tab <- torch_tensor(as.matrix(data[, c(1, 2, 3, 4)])) data_img <- torch_stack(lapply(data$full_path, function(x) {   base_loader(here(paste0(\"vignettes/articles/real_data/test/\", x))) %>%     (function(x) x[,,1:3]) %>%     transform_to_tensor() %>%     transform_center_crop(226) %>%     transform_normalize(mean = c(0.485, 0.456, 0.406), std = c(0.229, 0.224, 0.225)) }), dim = 1)"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"explain-model","dir":"Articles","previous_headings":"","what":"Explain model","title":"Example on Real Multi-modal Medical Data","text":"apply several gradient-based feature attribution techniques adapted survival analysis explain model‚Äôs prediction selected test instance: Grad(t): Simple backpropagation-based gradients respect input. SG(t): noise-averaged version gradients improve local fluctuations gradients. IG(t): path-based method accumulates gradients along linear interpolation baseline input. example, use mean baseline. GradSHAP(t): approximation SHAP values using randomized baseline samples combined gradient integration. method runs moderate batch size 10 fixed number samples ensure computational feasibility. better estimates, recommend using larger sample sizes number integration points, may lead increased memory usage longer computation times. explanations stored data.tables downstream visualization.","code":"exp_deephit <- survinng::explain(model, list(data_img, data_tab),                                   model_type = \"deephit\",                                  time_bins = seq(0, 17, length.out = n_out))  ids <- 230 orig_img <- base_loader(here(paste0(\"vignettes/articles/real_data/test/\", data[ids, ]$full_path)))  # Run Grad(t) grad <- surv_grad(exp_deephit, instance = ids, batch_size = 10) gc()  # Run SG(t) sgrad <- surv_smoothgrad(exp_deephit, instance = ids, n = 50,                           noise_level = 0.3, batch_size = 10) gc()  # Run IntGrad(t) intgrad <- surv_intgrad(exp_deephit, instance = ids, n = 50, batch_size = 10)  gc()  # Run GradSHAP(t) grad_shap <- surv_gradSHAP(exp_deephit, instance = ids, n = 10, num_samples = 50,                             batch_size = 10, replace = FALSE)  gc()  # Convert to data.tables grad <- as.data.table(grad) sgrad <- as.data.table(sgrad) intgrad <- as.data.table(intgrad) grad_shap <- as.data.table(grad_shap)"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"visualize-results","dir":"Articles","previous_headings":"","what":"Visualize results","title":"Example on Real Multi-modal Medical Data","text":"method, visualize: original image. pixel-wise relevance heatmap. combined view aligning tabular image attributions. plots enable comparative interpretation attribution method highlights relevant regions image important features tabular input time. particular, visualizations allow us examine consistency plausibility attributions across methods, offering insight internal reasoning survival model.","code":""},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"plot-gradt","dir":"Articles","previous_headings":"Visualize results","what":"Plot Grad(t)","title":"Example on Real Multi-modal Medical Data","text":"","code":"plots <- plot_result(grad, orig_img, name = \"real_data_grad\", as_force = FALSE) plot_grid(plots[[1]],            plot_grid(plots[[3]], plots[[2]], nrow = 1, rel_widths = c(1, 7)),           rel_heights = c(1, 0.25), nrow = 2)"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"plot-sgt","dir":"Articles","previous_headings":"Visualize results","what":"Plot SG(t)","title":"Example on Real Multi-modal Medical Data","text":"","code":"plots <- plot_result(sgrad, orig_img, name = \"real_data_sgrad\", as_force = FALSE) plot_grid(plots[[1]],            plot_grid(plots[[3]], plots[[2]], nrow = 1, rel_widths = c(1, 7)),           rel_heights = c(1, 0.25), nrow = 2)"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"plot-intgradt","dir":"Articles","previous_headings":"Visualize results","what":"Plot IntGrad(t)","title":"Example on Real Multi-modal Medical Data","text":"","code":"plots <- plot_result(intgrad, orig_img, name = \"real_data_intgrad\", as_force = TRUE) plot_grid(plots[[4]],            plot_grid(plots[[3]], plots[[2]], nrow = 1, rel_widths = c(1, 7)),           rel_heights = c(1, 0.25), nrow = 2)"},{"path":"https://bips-hb.github.io/survinng/articles/multimodal.html","id":"plot-gradshapt","dir":"Articles","previous_headings":"Visualize results","what":"Plot GradSHAP(t)","title":"Example on Real Multi-modal Medical Data","text":"","code":"plots <- plot_result(grad_shap, orig_img, name = \"real_data_gradshap\", as_force = TRUE) plot_grid(plots[[4]],            plot_grid(plots[[3]], plots[[2]], nrow = 1, rel_widths = c(1, 7)),           rel_heights = c(1, 0.25), nrow = 2)"},{"path":"https://bips-hb.github.io/survinng/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Niklas Koenen. Author, maintainer. Sophie Hanna Langbein. Author.","code":""},{"path":"https://bips-hb.github.io/survinng/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Langbein, Hanna S, Koenen, Niklas, Wright, N. M (2025). ‚ÄúGradient-based Explanations Deep Learning Survival Models.‚Äù International Conference Machine Learning.","code":"@InProceedings{,   title = {Gradient-based Explanations for Deep Learning Survival Models},   author = {{Langbein} and Sophie Hanna and {Koenen} and {Niklas} and {Wright} and Marvin N.},   booktitle = {International Conference on Machine Learning},   year = {2025}, }"},{"path":"https://bips-hb.github.io/survinng/index.html","id":"survinng-gradient-based-explanations-for-deep-learning-survival-models","dir":"","previous_headings":"","what":"Gradient-Based Feature Attribution for Survival Neural Networks","title":"Gradient-Based Feature Attribution for Survival Neural Networks","text":"package survinng provides gradient-based feature attribution methods deep learning survival models. implements novel adaptions model-specific XAI methods survival analysis domain, like Grad(t), SG(t), GxI(t), IntGrad(t), GradSHAP(t). whole package designed compatible survivalmodels package R, R wrapper pycox Python package. However, can also used models pycox directly survival models loaded torch. Currently, package supports models types DeepSurv/CoxPH, DeepHit, CoxTime.","code":""},{"path":"https://bips-hb.github.io/survinng/index.html","id":"id_-why-survinng","dir":"","previous_headings":"","what":"üöÄ Why survinng?","title":"Gradient-Based Feature Attribution for Survival Neural Networks","text":"survinng, get: ‚è± Model-specific time-resolved feature attributions individuals ‚ö°Ô∏è Fast scalable explanations using model gradients, especially SHAP-like explanations ü§ù Compatible survivalmodels pycox models üìä Easy--use visualization tools temporal insights üîÄ Support multimodal inputs (e.g., tabular + image) Overall, package part following ICML‚Äô25 paper: üìÑ Based ICML 2025 paper:Gradient-based Explanations Deep Learning Survival ModelsSophie Hanna Langbein, Niklas Koenen, Marvin N. Wright","code":""},{"path":"https://bips-hb.github.io/survinng/index.html","id":"id_-installation","dir":"","previous_headings":"","what":"üì¶ Installation","title":"Gradient-Based Feature Attribution for Survival Neural Networks","text":"install latest development version directly GitHub:","code":"# install.packages(\"devtools\") devtools::install_github(\"bips-hb/survinng\")"},{"path":"https://bips-hb.github.io/survinng/index.html","id":"id_-usage","dir":"","previous_headings":"","what":"üìñ Usage","title":"Gradient-Based Feature Attribution for Survival Neural Networks","text":"trained survival neural network model survivalmodels pycox model input data data. Now want interpret individual data points using methods package survinng, stick following pseudo code: üëâ full documentation advanced use cases, visit üìò package website.","code":"library(survinng)  # Load a survival model and corresponding data model <- ... (e.g., from survivalmodels or pycox) data <- ... (e.g., the test set of the model)  # Create explainer object explainer <- survinng::explain(model, data)  # Compute feature attributions idx <- 1 # index of the instance to explain grad <- surv_grad(explainer, instance = idx) # Grad(t) sg <- surv_smoothgrad(explainer, instance = idx) # SG(t) gxi <- surv_grad(explainer, instance = idx, times_input = TRUE) # GxI(t) ig <- surv_intgrad(explainer, instance = idx) # IntGrad(t) shap <- surv_gradSHAP(explainer, instance = idx) # GradSHAP(t)  # Plot results plot(shap)"},{"path":"https://bips-hb.github.io/survinng/index.html","id":"id_-quick-example","dir":"","previous_headings":"","what":"üíª Quick Example","title":"Gradient-Based Feature Attribution for Survival Neural Networks","text":"","code":"library(survival) library(callr)  # Load lung dataset data(cancer, package=\"survival\") data <- na.omit(cancer[, c(1, 4, 5, 6, 7, 10, 2, 3)]) train <- data[1:150, ] test <- data[151:212, ]  # Train a DeepSurv model ext <- callr::r(function(train) {   library(survivalmodels)   library(survival)      # Fit the DeepSurv model   install_pycox(install_torch = TRUE) # Requires pycox   fit <- deepsurv(Surv(time, status) ~ ., data = train, epochs = 100,                   early_stopping = TRUE)    # Extract the model   survinng::extract_model(fit) }, args = list(train = train))   # Create explainer explainer <- explain(ext, data = test)  # Run GradSHAP(t) shap <- surv_gradSHAP(explainer)  # Plot results plot(shap)"},{"path":"https://bips-hb.github.io/survinng/index.html","id":"id_-other-examples-and-articles","dir":"","previous_headings":"","what":"üñ• Other Examples and Articles","title":"Gradient-Based Feature Attribution for Survival Neural Networks","text":"load model? ‚Üí article Simulation: Time-independent effects (survivalmodels) ‚Üí article Simulation: Time-dependent effects (survivalmodels) ‚Üí article Example real multi-modal medical data ‚Üí article","code":""},{"path":"https://bips-hb.github.io/survinng/index.html","id":"id_-citation","dir":"","previous_headings":"","what":"üìö Citation","title":"Gradient-Based Feature Attribution for Survival Neural Networks","text":"use package research, please cite follows:","code":"@article{langbein2025grad,   title={Gradient-based Explanations for Deep Learning Survival Models},   author={Langbein, Sophie Hanna and Koenen, Niklas and Wright, Marvin N.},   journal={arXiv preprint arXiv:2502.04970},   year={2025} }"},{"path":"https://bips-hb.github.io/survinng/reference/as.data.frame.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert survival attribution results to a data.frame ‚Äî as.data.frame.surv_result","title":"Convert survival attribution results to a data.frame ‚Äî as.data.frame.surv_result","text":"function converts survival attribution results data frame format. can handle stacked non-stacked formats.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/as.data.frame.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert survival attribution results to a data.frame ‚Äî as.data.frame.surv_result","text":"","code":"# S3 method for class 'surv_result' as.data.frame(x, ..., stacked = FALSE)  as.data.table.surv_result(x, ..., stacked = FALSE)"},{"path":"https://bips-hb.github.io/survinng/reference/as.data.frame.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert survival attribution results to a data.frame ‚Äî as.data.frame.surv_result","text":"x object class surv_result containing survival attribution results. ... Unused arguments. stacked Logical indicating whether convert stacked data frame, .e., attributions stacked top . Default FALSE.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/explain.html","id":null,"dir":"Reference","previous_headings":"","what":"Explain a model ‚Äî explain","title":"Explain a model ‚Äî explain","text":"function generic method dispatches appropriate explain method based class model.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/explain.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Explain a model ‚Äî explain","text":"","code":"explain(   model,   data = NULL,   model_type = NULL,   baseline_hazard = NULL,   labtrans = NULL,   time_bins = NULL,   preprocess_fun = NULL,   postprocess_fun = NULL,   predict_fun = NULL )  # S3 method for class 'nn_module' explain(   model,   data,   model_type,   baseline_hazard = NULL,   labtrans = NULL,   time_bins = NULL,   preprocess_fun = NULL,   postprocess_fun = NULL,   predict_fun = NULL )  # S3 method for class 'extracted_survivalmodels_coxtime' explain(model, data, ...)  # S3 method for class 'extracted_survivalmodels_deephit' explain(model, data, ...)  # S3 method for class 'extracted_survivalmodels_deepsurv' explain(model, data, ...)"},{"path":"https://bips-hb.github.io/survinng/reference/explain.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Explain a model ‚Äî explain","text":"model model object. data data frame matrix data explain model. model_type string specifying type survival model. Possible values \"coxtime\", \"deephit\", \"deepsurv\". baseline_hazard data frame containing baseline hazard. two columns: \"time\" \"hazard\". used \"coxtime\" \"deepsurv\" models. labtrans list containing transformation functions time variable. two elements: \"transform\" \"transform_inv\". highly experimental yet fully supported. time_bins numeric vector specifying time bins \"deephit\" model, e.g., c(0, 1, 2, 3). preprocess_fun function preprocess data making predictions, e.g., adding time variable coxtime model. argument highly experimental default values work cases. postprocess_fun function postprocess predictions making . argument highly experimental default values work. predict_fun function can used make predictions model. NULL, predict method model used. ... Unused arguments.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/explain.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Explain a model ‚Äî explain","text":"object class explainer contains model, data, prediction function.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/extract_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract model information from a survivalmodels object ‚Äî extract_model","title":"Extract model information from a survivalmodels object ‚Äî extract_model","text":"function extracts model information neural network trained survivalmodels package.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/extract_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract model information from a survivalmodels object ‚Äî extract_model","text":"","code":"extract_model(x, path = NULL, num_basehazard = 200L)  # S3 method for class 'coxtime' extract_model(x, path = NULL, num_basehazard = 200L)  # S3 method for class 'deephit' extract_model(x, path = NULL, ...)  # S3 method for class 'deepsurv' extract_model(x, path = NULL, num_basehazard = 200L)"},{"path":"https://bips-hb.github.io/survinng/reference/extract_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract model information from a survivalmodels object ‚Äî extract_model","text":"x survivalmodels object, .e., survivalmodels::deephit, survivalmodels::coxtime, survivalmodels::deepsurv. path string specifying path save extracted model. NULL, model saved. Default NULL. num_basehazard integer specifying number points baseline hazard compute. Default 200L. argument used coxtime deepsurv models. ... Unused arguments.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/plot.surv_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Methods for Survival Attribution Results ‚Äî plot.surv_result","title":"Plot Methods for Survival Attribution Results ‚Äî plot.surv_result","text":"Visualize survival predictions, feature attributions, contribution percentages force plots survival results. latter two specifically GradSHAP(t) IntGrad(t) methods.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/plot.surv_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Methods for Survival Attribution Results ‚Äî plot.surv_result","text":"","code":"# S3 method for class 'surv_result' plot(x, ..., type = \"attr\")  plot_force(x, num_bars = 10)  plot_pred(x)  plot_attr(x, normalize = \"none\", add_comp = NULL)  plot_contr(x, aggregate = FALSE)"},{"path":"https://bips-hb.github.io/survinng/reference/plot.surv_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Methods for Survival Attribution Results ‚Äî plot.surv_result","text":"x object class surv_result containing survival attribution results. ... (unsed arguments) type Type plot generate using generic plot() method. Options: \"pred\": plot survival predictions time \"attr\": plot feature attributions time (default) \"contr\": plot feature contributions percentages time \"force\": plot force plots instance num_bars Number bars show force plot. Default 10. normalize Normalization method plot_attr(). Options: \"none\" (default): normalization \"abs\": normalize sum absolute values \"rel\": normalize sum values Note: recommended visualization GradSHAP(t) IntGrad(t) results. add_comp Optional vector comparison curves add attribution plot (plot_attr() ). Options include: \"pred\": predicted survival curve \"pred_ref\": reference survival curve \"pred_diff\": difference prediction reference can also specify \"\" include three curves. Default NULL. aggregate Logical; TRUE, contributions aggregated across instances plot_contr(). FALSE (default), one panel per instance shown.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/plot.surv_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Methods for Survival Attribution Results ‚Äî plot.surv_result","text":"ggplot2 object.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/plot.surv_result.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot Methods for Survival Attribution Results ‚Äî plot.surv_result","text":"functions provide convenient way visualize results survival attribution methods: plot() generic wrapper dispatches appropriate plot type based type argument. plot_pred() visualizes survival predictions across time selected instances. plot_attr() displays time-resolved attributions time per instance. following methods available GradSHAP(t) IntGrad(t): plot_contr() visualizes relative contribution features time, optionally aggregated across instances global insights. plot_force() generates force plots showing features' effect prediction time.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/print.explainer.html","id":null,"dir":"Reference","previous_headings":"","what":"Custom print method for explainer objects ‚Äî print.explainer_coxtime","title":"Custom print method for explainer objects ‚Äî print.explainer_coxtime","text":"function prints summary explainer object.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/print.explainer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Custom print method for explainer objects ‚Äî print.explainer_coxtime","text":"","code":"# S3 method for class 'explainer_coxtime' print(x, ...)  # S3 method for class 'explainer_deepsurv' print(x, ...)  # S3 method for class 'explainer_deephit' print(x, ...)"},{"path":"https://bips-hb.github.io/survinng/reference/print.explainer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Custom print method for explainer objects ‚Äî print.explainer_coxtime","text":"x object class 'explainer_coxtime', 'explainer_deepsurv', 'explainer_deephit'. ... Additional arguments (used).","code":""},{"path":"https://bips-hb.github.io/survinng/reference/print.extracted_survivalmodels.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for extracted pycox survival model ‚Äî print.extracted_survivalmodels_coxtime","title":"Print method for extracted pycox survival model ‚Äî print.extracted_survivalmodels_coxtime","text":"Print method extracted pycox survival model","code":""},{"path":"https://bips-hb.github.io/survinng/reference/print.extracted_survivalmodels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for extracted pycox survival model ‚Äî print.extracted_survivalmodels_coxtime","text":"","code":"# S3 method for class 'extracted_survivalmodels_coxtime' print(x, ...)  # S3 method for class 'extracted_survivalmodels_deepsurv' print(x, ...)  # S3 method for class 'extracted_survivalmodels_deephit' print(x, ...)"},{"path":"https://bips-hb.github.io/survinng/reference/print.extracted_survivalmodels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for extracted pycox survival model ‚Äî print.extracted_survivalmodels_coxtime","text":"x object class extracted_survivalmodels_coxtime, extracted_survivalmodels_deepsurv, extracted_survivalmodels_deephit. ... Additional arguments (used).","code":""},{"path":"https://bips-hb.github.io/survinng/reference/print.surv_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print function for surv_result objects ‚Äî print.surv_result","title":"Print function for surv_result objects ‚Äî print.surv_result","text":"Print function surv_result objects","code":""},{"path":"https://bips-hb.github.io/survinng/reference/print.surv_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print function for surv_result objects ‚Äî print.surv_result","text":"","code":"# S3 method for class 'surv_result' print(x, ...)"},{"path":"https://bips-hb.github.io/survinng/reference/print.surv_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print function for surv_result objects ‚Äî print.surv_result","text":"x object class \"surv_result\" ... Additional arguments (used)","code":""},{"path":"https://bips-hb.github.io/survinng/reference/surv_grad.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Gradient of the Survival Function ‚Äî surv_grad","title":"Calculate the Gradient of the Survival Function ‚Äî surv_grad","text":"function calculates gradient survival function respect input features time points given instance. paper, referred \"Grad(t)\" method. shows sensitivity survival function changes input features specific time point.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/surv_grad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Gradient of the Survival Function ‚Äî surv_grad","text":"","code":"surv_grad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 50,   dtype = \"float\",   include_time = FALSE )  # S3 method for class 'explainer_deepsurv' surv_grad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 1000,   dtype = \"float\",   ... )  # S3 method for class 'explainer_coxtime' surv_grad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 1000,   dtype = \"float\",   include_time = FALSE )  # S3 method for class 'explainer_deephit' surv_grad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 1000,   dtype = \"float\",   ... )"},{"path":"https://bips-hb.github.io/survinng/reference/surv_grad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Gradient of the Survival Function ‚Äî surv_grad","text":"exp object class explainer_deepsurv, explainer_coxtime, explainer_deephit. target character string indicating target output. DeepSurv CoxTime, can either \"survival\" (default), \"cum_hazard\", \"hazard\". DeepHit, can \"survival\" (default), \"cif\", \"pmf\". instance integer specifying instance gradient calculated. 1 number instances dataset. times_input logical value indicating whether gradient multiplied input. paper, variant referred \"GxI(t)\". batch_size integer specifying batch size processing. default 1000. value describes number instances within one batch final number rows batch. example, CoxTime replicates instance time point. dtype character string indicating data type tensors. can either \"float\" (default) \"double\". include_time logical value indicating whether include time points output. relevant CoxTime ignored DeepSurv DeepHit. ... Unused arguments.","code":""},{"path":[]},{"path":"https://bips-hb.github.io/survinng/reference/surv_gradSHAP.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the GradSHAP values of the Survival Function ‚Äî surv_gradSHAP","title":"Calculate the GradSHAP values of the Survival Function ‚Äî surv_gradSHAP","text":"function calculates GradSHAP values survival function respect input features time points given instance. paper, referred \"GradSHAP(t)\" method. fast model-specific method calculating Shapley values deep survival model.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/surv_gradSHAP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the GradSHAP values of the Survival Function ‚Äî surv_gradSHAP","text":"","code":"surv_gradSHAP(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 1000,   n = 50,   num_samples = 10,   data_ref = NULL,   dtype = \"float\",   replace = TRUE,   include_time = FALSE )  # S3 method for class 'explainer_deepsurv' surv_gradSHAP(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 1000,   n = 50,   num_samples = 10,   data_ref = NULL,   dtype = \"float\",   replace = TRUE,   ... )  # S3 method for class 'explainer_coxtime' surv_gradSHAP(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 1000,   n = 50,   num_samples = 10,   data_ref = NULL,   dtype = \"float\",   replace = TRUE,   include_time = FALSE )  # S3 method for class 'explainer_deephit' surv_gradSHAP(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 1000,   n = 50,   num_samples = 10,   data_ref = NULL,   dtype = \"float\",   replace = TRUE,   ... )"},{"path":"https://bips-hb.github.io/survinng/reference/surv_gradSHAP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the GradSHAP values of the Survival Function ‚Äî surv_gradSHAP","text":"exp object class explainer_deepsurv, explainer_coxtime, explainer_deephit. target character string indicating target output. DeepSurv CoxTime, can either \"survival\" (default), \"cum_hazard\", \"hazard\". DeepHit, can \"survival\" (default), \"cif\", \"pmf\". instance integer specifying instance GradSHAP values calculated. 1 number instances dataset. times_input logical value indicating whether GradSHAP values multiplied input. batch_size integer specifying batch size processing. default 1000. value describes number instances within one batch final number rows batch. example, CoxTime replicates instance time point. n integer specifying number samples used approximating integral. default 50. num_samples integer specifying number samples used baseline distribution. default 10. data_ref reference dataset sampling. NULL, reference dataset taken input data model. dataset contain number features input data. dtype character string indicating data type tensors. can either \"float\" (default) \"double\". replace logical value indicating whether sample baseline distribution replacement. default TRUE. include_time logical value indicating whether calculate GradSHAP also time point. relevant CoxTime ignored DeepSurv DeepHit. default FALSE. ... Unused arguments. #' @return Returns object class surv_result.","code":""},{"path":[]},{"path":"https://bips-hb.github.io/survinng/reference/surv_intgrad.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Integrated Gradients of the Survival Function ‚Äî surv_intgrad","title":"Calculate the Integrated Gradients of the Survival Function ‚Äî surv_intgrad","text":"function calculates integrated gradients survival function respect input features time points given instance. paper, referred \"IntGrad(t)\" method. shows attributions input features target function respect reference input.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/surv_intgrad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Integrated Gradients of the Survival Function ‚Äî surv_intgrad","text":"","code":"surv_intgrad(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 50,   n = 10,   x_ref = NULL,   dtype = \"float\",   include_time = FALSE )  # S3 method for class 'explainer_deepsurv' surv_intgrad(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 1000,   n = 10,   x_ref = NULL,   dtype = \"float\",   ... )  # S3 method for class 'explainer_coxtime' surv_intgrad(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 1000,   n = 10,   x_ref = NULL,   dtype = \"float\",   include_time = FALSE )  # S3 method for class 'explainer_deephit' surv_intgrad(   exp,   target = \"survival\",   instance = 1,   times_input = TRUE,   batch_size = 1000,   n = 10,   x_ref = NULL,   dtype = \"float\",   ... )"},{"path":"https://bips-hb.github.io/survinng/reference/surv_intgrad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the Integrated Gradients of the Survival Function ‚Äî surv_intgrad","text":"exp object class explainer_deepsurv, explainer_coxtime, explainer_deephit. target character string indicating target output. DeepSurv CoxTime, can either \"survival\" (default), \"cum_hazard\", \"hazard\". DeepHit, can \"survival\" (default), \"cif\", \"pmf\". instance integer specifying instance integrated gradients calculated. 1 number instances dataset. times_input logical value indicating whether integrated gradients multiplied input. Default TRUE. batch_size integer specifying batch size processing. default 1000. value describes number instances within one batch final number rows batch. example, CoxTime replicates instance time point. n integer specifying number approximation points integral calculation. Default 10. x_ref reference input integrated gradients. NULL (default), mean input data used. dimensions input data. dtype character string indicating data type tensors. can either \"float\" (default) \"double\". include_time logical value indicating whether include attributions time points. relevant CoxTime ignored DeepSurv DeepHit. ... Unused arguments.","code":""},{"path":[]},{"path":"https://bips-hb.github.io/survinng/reference/surv_smoothgrad.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the SmoothGrad values of the Survival Function ‚Äî surv_smoothgrad","title":"Calculate the SmoothGrad values of the Survival Function ‚Äî surv_smoothgrad","text":"function calculates SmoothGrad values survival function respect input features time points given instance. paper, referred \"SG(t)\" method. shows smoothed sensitivity survival function changes input features specific time point.","code":""},{"path":"https://bips-hb.github.io/survinng/reference/surv_smoothgrad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the SmoothGrad values of the Survival Function ‚Äî surv_smoothgrad","text":"","code":"surv_smoothgrad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 50,   n = 10,   noise_level = 0.1,   dtype = \"float\",   include_time = FALSE )  # S3 method for class 'explainer_deepsurv' surv_smoothgrad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 1000,   n = 10,   noise_level = 0.1,   dtype = \"float\",   ... )  # S3 method for class 'explainer_coxtime' surv_smoothgrad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 1000,   n = 10,   noise_level = 0.1,   dtype = \"float\",   include_time = FALSE )  # S3 method for class 'explainer_deephit' surv_smoothgrad(   exp,   target = \"survival\",   instance = 1,   times_input = FALSE,   batch_size = 1000,   n = 10,   noise_level = 0.1,   dtype = \"float\",   ... )"},{"path":"https://bips-hb.github.io/survinng/reference/surv_smoothgrad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the SmoothGrad values of the Survival Function ‚Äî surv_smoothgrad","text":"exp object class explainer_deepsurv, explainer_coxtime, explainer_deephit. target character string indicating target output. DeepSurv CoxTime, can either \"survival\" (default), \"cum_hazard\", \"hazard\". DeepHit, can \"survival\" (default), \"cif\", \"pmf\". instance integer specifying instance SmoothGrad calculated. 1 number instances dataset. times_input logical value indicating whether SmoothGrad multiplied input. paper, variant referred \"SGxI(t)\". batch_size integer specifying batch size processing. default 1000. value describes number instances within one batch final number rows batch. example, CoxTime replicates instance time point. n integer specifying number noise samples added input features. default 10. noise_level numeric value specifying level Gaussian noise added input features. default 0.1. dtype character string indicating data type tensors. can either \"float\" (default) \"double\". include_time logical value indicating whether also calculate gradients respect time. relevant CoxTime ignored DeepSurv DeepHit. ... Unused arguments.","code":""},{"path":[]},{"path":"https://bips-hb.github.io/survinng/reference/survinng-package.html","id":null,"dir":"Reference","previous_headings":"","what":"survinng: Gradient-Based Feature Attribution for Survival Neural Networks ‚Äî survinng-package","title":"survinng: Gradient-Based Feature Attribution for Survival Neural Networks ‚Äî survinng-package","text":"package implements model-specific, gradient-based feature attribution methods deep survival neural networks, including DeepHit, CoxTime, DeepSurv. accompanies ICML 2025 paper \"Gradient-based Explanations Deep Learning Survival Models\".","code":""},{"path":[]},{"path":"https://bips-hb.github.io/survinng/reference/survinng-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"survinng: Gradient-Based Feature Attribution for Survival Neural Networks ‚Äî survinng-package","text":"Maintainer: Niklas Koenen niklas.koenen@gmail.com (ORCID) Authors: Sophie Hanna Langbein (ORCID)","code":""},{"path":"https://bips-hb.github.io/survinng/news/index.html","id":"survinng-010","dir":"Changelog","previous_headings":"","what":"survinng 0.1.0","title":"survinng 0.1.0","text":"Initial release part ICML‚Äô25 paper Gradient-based Explanations Deep Learning Survival Models","code":""}]
